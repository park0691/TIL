<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.15" />
    <style>
      :root {
        --c-bg: #fff;
      }

      html.dark {
        --c-bg: #22272e;
      }

      html,
      body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches

      if (userMode === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (userMode === 'dark' || systemDarkMode) {
        document.documentElement.classList.toggle('dark', true)
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>Hashing | depark's note</title><meta name="description" content="">
    <link rel="preload" href="/TIL/assets/style-J1DHsHYO.css" as="style"><link rel="stylesheet" href="/TIL/assets/style-J1DHsHYO.css">
    <link rel="modulepreload" href="/TIL/assets/app-82ene1kh.js"><link rel="modulepreload" href="/TIL/assets/collections-hashing.html-qbynhOxA.js">
    <link rel="prefetch" href="/TIL/assets/index.html-DOxI3Tvi.js" as="script"><link rel="prefetch" href="/TIL/assets/index.html-xttLGo8N.js" as="script"><link rel="prefetch" href="/TIL/assets/transaction.html-D0-8Xgzj.js" as="script"><link rel="prefetch" href="/TIL/assets/functional-interface-lambda.html-DWKkUTxt.js" as="script"><link rel="prefetch" href="/TIL/assets/generics.html-D6YEBEF8.js" as="script"><link rel="prefetch" href="/TIL/assets/jvm-class-loader.html-zGWKnwSk.js" as="script"><link rel="prefetch" href="/TIL/assets/jvm-garbage-collector.html-B0hXNLXs.js" as="script"><link rel="prefetch" href="/TIL/assets/jvm-gc-algorithm.html-CpD2mpTn.js" as="script"><link rel="prefetch" href="/TIL/assets/jvm-runtime-data-area.html-DJFq0Mk_.js" as="script"><link rel="prefetch" href="/TIL/assets/reactive-programming-basic.html-C-DVxnO9.js" as="script"><link rel="prefetch" href="/TIL/assets/thread-callable-future-executor.html-B-urHal4.js" as="script"><link rel="prefetch" href="/TIL/assets/thread-completable-future.html-C6biqhIg.js" as="script"><link rel="prefetch" href="/TIL/assets/thread-fork-join.html-CNd4dJAz.js" as="script"><link rel="prefetch" href="/TIL/assets/thread-runnable.html-Cnn4gVnK.js" as="script"><link rel="prefetch" href="/TIL/assets/aop.html-CThw16Y1.js" as="script"><link rel="prefetch" href="/TIL/assets/section-02.html-3jOXUB2T.js" as="script"><link rel="prefetch" href="/TIL/assets/section-03.html-BlqVWiMg.js" as="script"><link rel="prefetch" href="/TIL/assets/section-04.html-vvkPTV4j.js" as="script"><link rel="prefetch" href="/TIL/assets/toby-ch-06-aop.html-BBzKpWwI.js" as="script"><link rel="prefetch" href="/TIL/assets/404.html-ZG9WnGw-.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon"><!--[--><header class="vp-navbar"><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/TIL/"><!----><span class="vp-site-name" aria-hidden="true">depark&#39;s note</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="auto-link external-link" href="https://park0691.github.io/" aria-label="Blog" rel="noopener noreferrer" target="_blank"><!---->Blog<!----></a></div><!--]--></nav><!--[--><!--]--><button class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar"><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="auto-link external-link" href="https://park0691.github.io/" aria-label="Blog" rel="noopener noreferrer" target="_blank"><!---->Blog<!----></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Book / Lecture <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><p tabindex="0" class="vp-sidebar-item">토비의 스프링 3.1 <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/book-lecture/toby-spring/toby-ch-06-aop.html" aria-label="CH6. AOP"><!---->CH6. AOP<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item">Spring Security 6 완전 정복 <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/book-lecture/spring-security-v6/section-02.html" aria-label="초기화 과정"><!---->초기화 과정<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/book-lecture/spring-security-v6/section-03.html" aria-label="인증 프로세스"><!---->인증 프로세스<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/book-lecture/spring-security-v6/section-04.html" aria-label="인증 아키텍처"><!---->인증 아키텍처<!----></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading active">Java <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><p tabindex="0" class="vp-sidebar-item">JVM, Java Virtual Machine <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/java/jvm-class-loader.html" aria-label="Class Loader"><!---->Class Loader<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/java/jvm-runtime-data-area.html" aria-label="Runtime Data Area"><!---->Runtime Data Area<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/java/jvm-gc-algorithm.html" aria-label="Garbage Collection Algorithm"><!---->Garbage Collection Algorithm<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/java/jvm-garbage-collector.html" aria-label="Garbage Collector"><!---->Garbage Collector<!----></a><!----></li><!--]--></ul></li><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/java/generics.html" aria-label="Generics"><!---->Generics<!----></a><!----></li><li><p tabindex="0" class="vp-sidebar-item active">Collections <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link route-link-active auto-link vp-sidebar-item active" href="/TIL/java/collections-hashing.html" aria-label="Hashing"><!---->Hashing<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item">Thread Programming <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/java/thread-runnable.html" aria-label="Thread, Runnable"><!---->Thread, Runnable<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/java/thread-fork-join.html" aria-label="Fork, Join, RecursiveTask"><!---->Fork, Join, RecursiveTask<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/java/thread-callable-future-executor.html" aria-label="Callable, Future, Executor"><!---->Callable, Future, Executor<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/java/thread-completable-future.html" aria-label="CompletableFuture"><!---->CompletableFuture<!----></a><!----></li><!--]--></ul></li><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/java/reactive-programming-basic.html" aria-label="Reactive Programming"><!---->Reactive Programming<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/java/functional-interface-lambda.html" aria-label="함수형 인터페이스와 람다"><!---->함수형 인터페이스와 람다<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Spring <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/spring/aop.html" aria-label="AOP"><!---->AOP<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Database <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/database/transaction.html" aria-label="Transaction"><!---->Transaction<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/TIL/database/" aria-label="Index"><!---->Index<!----></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="hashing" tabindex="-1"><a class="header-anchor" href="#hashing"><span>Hashing</span></a></h1><h2 id="hash" tabindex="-1"><a class="header-anchor" href="#hash"><span>Hash</span></a></h2><ul><li>임의 크기의 key를 고정된 크기의 데이터로 변환시켜 저장하는 것 <ul><li>해시 자체는 고정된 길이의 데이터를 의미한다.</li></ul></li><li>키에 대한 해시값을 구하는 과정을 해싱(hashing)이라 한다.</li><li>해시값 자체를 index로 사용하기 떄문에 시간 복잡도 O(1)로 매우 빠르다. <ul><li>테이블 크기에 상관없이 데이터에 빠르게 접근 가능</li><li>모든 데이터를 살피지 않아도 검색과 삽입, 삭제 빠르게 수행</li></ul></li></ul><h3 id="hash-함수" tabindex="-1"><a class="header-anchor" href="#hash-함수"><span>Hash 함수</span></a></h3><ul><li>키에 대한 해시 값을 만드는 함수 (알고리즘)</li><li>복잡하지 않은 알고리즘으로 구현되어 상대적으로 CPU, 메모리 리소스 등 자원을 덜 소모한다.</li><li>같은 입력 값에 대해서 같은 출력 값을 보장한다.</li><li>복호화 불가능 (단방향 암호화)</li><li>대표적으로 <code>나눗셈법(division method), 곱셈법(multiplication method)</code>이 있다.</li></ul><div class="custom-container tip"><p class="custom-container-title">좋은 해시 함수란? Simple, Uniform Hash</p><p>해시값은 해시값 범위(0 ~ size -1)를 동일한 확률로 (골고루, 균일하게) 나타낼 것<br> → 충돌 확률 감소</p><p>각 해시값들은 서로 연관성 갖지 않고 독립적으로 생성될 것<br> → 해시값들이 서로 연관되면 해당 해시 값이 나타나는 패턴, 순서가 존재할 수 있어 반복적인 해시 충돌 확률이 있기 떄문에 독립적으로 생성되는 것이 좋다.</p><p>&lt;정리&gt; 계산이 복잡하지 않고, 해시값의 충돌 없이 고르게 만들어내는 함수가 좋다.</p></div><h2 id="hash-collision" tabindex="-1"><a class="header-anchor" href="#hash-collision"><span>Hash Collision</span></a></h2><p>다른 크기의 해시값이 동일한 상황을 의미한다.</p><h3 id="open-addressing-개방-주소법" tabindex="-1"><a class="header-anchor" href="#open-addressing-개방-주소법"><span>Open Addressing, 개방 주소법</span></a></h3><ul><li>한 버킷 당 들어갈 수 있는 엔트리는 단 하나로 고정</li><li>데이터가 저장될 해시 버킷이 이미 사용 중인 경우 놀고 있는 다른 버킷을 찾아 데이터를 삽입한다.</li><li>해시 버킷을 찾을 때 <code>Linear Probing, Quadratic Probing</code> 등의 방법을 사용한다.</li><li>탐색 시간 복잡도 worst O(N), 버킷 사이즈 N</li></ul><p><strong>[장점]</strong></p><ul><li>인덱스에 직접 데이터를 저장하므로 메모리 효율이 좋다.</li><li>연속된 공간에 데이터를 저장하므로 캐싱 효율이 좋다. <ul><li>그러나 버킷 사이즈 커질 수록 캐싱 효율 떨어져 적은 데이터에 적합</li></ul></li><li>포인터가 필요 없어 구현이 용이하며, 포인터 접근에 필요한 시간이 없기 때문에 Separate Chaining 방식에 비해 성능이 좋다. (하지만 테이블 크기가 커지면 장점이 사라짐)</li></ul><p><strong>[단점]</strong></p><ul><li>정해진 해시 버킷 사이즈 이상 저장할 수 없다. (Chaining 방식은 데이터를 무한정 저장 가능)</li><li>클러스터링 문제 <ul><li>특정 영역에 데이터가 몰리는 상황이 발생 (해시 충돌 횟수 증가) → 성능 저하</li></ul></li><li>데이터 삭제의 비효율 <ul><li>3개 데이터가 동일한 해시인 1이 나와서 연속적인 공간 1, 2, 3번 버킷에 저장됬을 때</li><li>2번 버킷이 삭제된다면 중간에 저장된 값들이 이가 빠지듯이 삭제될 것이고, 삭제된 값 이후의 값 3번 버킷을 검색할 때 어려움이 있을 수 있다.</li><li>별도로 삭제된 버킷을 관리해야 하므로 추가 메모리 공간 필요</li></ul><blockquote><p><strong>슬롯의 상태 정보를 별도로 관리해야 하는 이유</strong><br> 9번째(idx : 2)를 삭제한다면, 9자리(idx : 2)의 상태를 DELETED로 바꾼다.<br> idx : 2를 검색할 때 해당 인덱스에 DELETED가 표시되어 충돌 발생을 의심하여 다음 칸을 검사한다. 만약 EMPTY 표시되었다면, 데이터가 존재하지 않는다 판단하여 탐색을 바로 종료할 것이다.</p></blockquote><ul><li>상태를 별도로 저장하여 관리하면 검색에 지장이 없을 수 있지만, 빈 더미를 지나가기 때문에 탐색 시간은 비효율적.</li></ul></li></ul><h4 id="linear-probing-선형-탐사법" tabindex="-1"><a class="header-anchor" href="#linear-probing-선형-탐사법"><span>Linear Probing, 선형 탐사법</span></a></h4><ul><li>충돌 발생 시 선형으로 순차 탐색하는 방법을 말한다.</li><li><em><strong>Probing</strong></em> : 값이 없다면 해당 버킷에 할당하고 있다면 다음 버킷으로 이동한다.</li></ul><blockquote><p><strong>예를 들어</strong><br> key % 7 해시 함수가 있다면, key 9를 저장할 때 idx 2에 저장한다. 이어서 해시 값이 2가 나오는 다른 데이터가 등장했을 때도 충돌로 idx 2에 저장할텐데, 옆자리가 비어 있으므로 idx 3에 저장한다.</p></blockquote><p><strong>[단점]</strong></p><ul><li>충돌이 발생할 수록 새로운 해시 값을 찾는 시간 증가 (성능 저하)</li><li><strong>Clustering, 군집화 문제</strong><ul><li>모든 키가 특정 영역에 몰려 채워지는 문제가 발생할 수 있다. (주변의 키의 해싱해도 해시 충돌 발생 빈도 증가)</li><li>군집화된 값들을 순차적으로 방문하여 해시 성능이 크게 저하될 수 있다.</li><li>따라서, 선형 탐사법은 해시 충돌이 해시 값 전체에 균등하게 발생할 때 유용하다.</li></ul></li></ul><h4 id="quadratic-probing-제곱-탐사법" tabindex="-1"><a class="header-anchor" href="#quadratic-probing-제곱-탐사법"><span>Quadratic Probing, 제곱 탐사법</span></a></h4><ul><li>충돌 확률을 줄일 대안으로 나온 것이 좀 더 멀리서 빈 공간을 찾자는 아이디어</li><li>Linear Probing이 n 칸 옆의 슬롯을 검사한다면, Quadratic Probing은 충돌 발생시 n 제곱 칸 옆의 슬롯을 검사한다. <ul><li>Linear Probing : 고정 폭으로 증가시키며 탐색 (f(k) + n)</li><li>Quadratic Probing : 폭을 제곱시키며 탐색 (f(k) + n^2)</li></ul></li></ul><p><strong>[장점]</strong></p><ul><li>군집화 문제 해결<br> 데이터의 밀집도가 선형 탐사법보다 낮기 때문에 다른 해시 값까지 영향을 받아 연쇄적 충돌 발생 가능성 적어진다.</li></ul><p><strong>[단점]</strong></p><ul><li>속도 저하 (선형 방식에 비해 캐시 성능 떨어짐) - 캐시 지역성 감소<br> CPU 캐시는 메모리 접근 패턴이 연속적일 수록 효율이 높다. 선형 탐사는 충돌 시 바로 옆 슬롯을 연속적으로 접근하기 때문에 공간 지역성이 좋았지만, 제곱 탐사 방식은 탐색 위치가 비연속적이고 멀리 퍼지게 되므로 캐시 효율이 떨어진다. (더 많은 캐시 미스 발생, 캐시 적중률 감소)</li></ul><h4 id="double-hashing" tabindex="-1"><a class="header-anchor" href="#double-hashing"><span>Double Hashing</span></a></h4><ul><li>Quadratic Probing, Linear Probing에서 여전히 해결하지 못하는 문제<br> 해시 충돌 발생 시 빈 슬롯을 찾기 위해 접근하는 위치가 동일하므로, 접근 슬롯을 중심으로 클러스터 현상 발생 확률은 여전히 높다. → 클러스터링 최소화 목적</li><li>충돌 발생 시 빈 슬롯을 택하는 방법을 좀 더 불규칙하게 구성하기 위해 두 개의 해시 함수를 사용한다.</li><li>1차 해시 함수는 기존과 같이 키를 근거로 저장 위치를 결정, 2차 해시 함수는 충돌 발생 시 몇 칸 뒤에 저장할 지 결정한다.</li></ul><p><strong>[장점]</strong></p><ul><li>선형, 제곱 탐사보다 클러스터 발생 확률을 현저히 낮출 수 있다.</li><li>탐사 간격은 고정되지 않고 키에 따라 다르므로 충돌이 잘 퍼진다. (충돌 발생 가능선 가장 적음)</li></ul><p><strong>[단점]</strong></p><ul><li>탐색 위치가 불규칙하므로 선형, 제곱 탐사에 비해 캐시 성능은 떨어진다.</li><li>추가적인 해시 연산으로 가장 많은 연산량 요구 (해싱에 더 많은 시간 소요)</li></ul><h3 id="separate-chaining-분산-체이닝" tabindex="-1"><a class="header-anchor" href="#separate-chaining-분산-체이닝"><span>Separate Chaining, 분산 체이닝</span></a></h3><ul><li>버킷 당 들어가는 엔트리 수에 제한을 두지 않고, 각 버킷에 연결 리스트 또는 트리 형태로 데이터를 저장한다.</li><li><code>Closed Addressing</code> 방법이라고도 하며, 해시 테이블에 추가적인 메모리를 사용한다.</li><li>탐색 시간 복잡도 worst (모든 데이터가 같은 해시값을 가질 때) O(N), 버킷 사이즈 N</li></ul><p><strong>[장점]</strong></p><ul><li>구현이 간단하고 유연</li><li>동적으로 크기를 조절하기 쉽다.</li></ul><p><strong>[단점]</strong></p><ul><li>Open Addressing에 비해 추가적인 메모리 공간 필요</li><li>버킷에 할당된 테이블이 놀고 있는 현상 (공간 낭비)</li><li>체인이 길어지면 탐색 시간 복잡도 증가</li><li>연결 리스트의 캐싱 성능 좋지 않다. (길이가 길어지면 탐색 시간이 길어질 수 있다.)<br> 대신 레드-블랙 트리를 사용하여 충돌을 해결, 탐색 시간 개선할 수 있다.</li></ul><h3 id="비교" tabindex="-1"><a class="header-anchor" href="#비교"><span>비교</span></a></h3><ul><li><p>적재율이 작을 경우, Open Addressing 방식이 평균적으로 더 빠르다.<br> Open Addressing은 연속된 공간에 데이터를 저장하기 때문에 Separate Chaining에 비해 캐시 효율이 높다. 따라서, 데이터 개수가 적다면 Open Addressing 방식이 Separate Chaining 방식보다 효율이 좋다.<br> 하지만, 저장되는 데이터가 많아지면 캐시 효율의 장점이 사라진다. (Separate Chaining보다 느려진다.) 데이터가 많아질수록 연속된 메모리를 탐색해야 하는 (Worst Case) 빈도가 높아져 캐시 적중률이 낮아지기 때문이다.<br> Separate Chaining 방식은 해시 충돌이 잘 발생하지 않도록 조정할 수 있다면 Worst Case에 가까운 일이 발생하는 것을 줄일 수 있다.</p></li><li><p>시간 복잡도<br> 해시 버킷 사이즈 N일 때, 두 방법 모두 Worst Case O(N)</p></li></ul><blockquote><p><strong>Hashing with Buckets</strong><br> 동일한 해시에 하나 이상의 레코드를 저장할 수 있는 블럭을 의미</p></blockquote><h2 id="references" tabindex="-1"><a class="header-anchor" href="#references"><span>References</span></a></h2><ul><li>https://superohinsung.tistory.com/113</li><li>https://dkswnkk.tistory.com/679</li><li>https://braindisk.tistory.com/m/107</li><li>https://d2.naver.com/helloworld/831311</li><li>https://runa-nam.tistory.com/84</li></ul></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: mem29238@gmail.com">depark</span><!----><!--]--><!--]--></span></div></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/TIL/assets/app-82ene1kh.js" defer></script>
  </body>
</html>
