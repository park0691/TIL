import{_ as n,c as s,o as a,b as e}from"./app-DZCwbiSk.js";const p="/TIL/images/db/20241114-db-index-1.png",l="/TIL/images/db/20241114-db-index-2.png",t="/TIL/images/db/20241114-db-index-3.png",o="/TIL/images/db/20241114-db-index-4.png",i="/TIL/images/db/20241114-db-index-5.png",c="/TIL/images/db/20241114-db-index-6.png",r="/TIL/images/db/20241114-db-index-7.png",d="/TIL/images/db/20241114-db-index-8.png",u="/TIL/images/db/20241114-db-index-9.png",m="/TIL/images/db/20241114-db-index-10.png",k="/TIL/images/db/20241114-db-index-11.png",g="/TIL/images/db/20241114-db-index-12.png",b="/TIL/images/db/20241114-db-index-13.png",_={},h=e('<h1 id="index" tabindex="-1"><a class="header-anchor" href="#index"><span>Index</span></a></h1><p>책의 마지막에 있는 &quot;찾아보기&quot;가 <u>인덱스</u>에 비유된다면 책의 내용은 <u>데이터 파일</u>에 저장된 레코드 주소에 비유된다. DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 결과를 가져오려면 시간이 오래 걸린다. 그래서 칼럼의 값과 해당 레코드가 저장된 주소를 key-value 쌍으로 삼아 인덱스를 만들어준다. 책의 찾아보기도 ㄱ, ㄴ, ㄷ, ... 순으로 정렬되어 있는데 DBMS의 인덱스도 칼럼의 값을 주어진 순서로 미리 정렬해서 보관한다.</p><h3 id="분류" tabindex="-1"><a class="header-anchor" href="#분류"><span>분류</span></a></h3><ul><li>역할별 <ul><li>Primary Key <ul><li>레코드를 대표하는 칼럼의 값으로 만들어진 인덱스. 테이블에서 레코드를 식별하는 기준값이 되기 때문에 식별자라고도 부른다. PK는 NULL 값, 중복을 허용하지 않는다.</li></ul></li><li>Secondary Index <ul><li>UNIQUE INDEX는 PK와 성격이 비슷하고 PK를 대체할 수 있다 해서 대체키라고도 하는데 별도로 분류하기도 하고 그냥 세컨더리 인덱스로 분류하기도 한다.</li></ul></li></ul></li><li>데이터 저장 알고리즘별 <ul><li>B-Tree Index <ul><li>B-Tree 알고리즘은 가장 일반적으로 사용되는 인덱스 알고리즘.</li></ul></li><li>Hash Index <ul><li>칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원</li><li>값을 변형해서 인덱싱하므로 Prefix 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없다.</li><li>주로 메모리 기반의 데이터베이스에서 많이 사용한다.</li></ul></li></ul></li><li>데이터의 중복 허용 여부 <ul><li>UNIQUE 인덱스</li><li>NON-UNIQUE 인덱스</li><li>실제 DBMS 쿼리를 실행해야 하는 옵티마이저에게는 상당히 중요한 문제다. 유니크 인덱스에 대해 동등 조건(Equal, =)으로 검색하는 것은 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.</li></ul></li></ul><h2 id="b-tree-인덱스" tabindex="-1"><a class="header-anchor" href="#b-tree-인덱스"><span>B-Tree 인덱스</span></a></h2><p>B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.</p><h3 id="구조-및-특성" tabindex="-1"><a class="header-anchor" href="#구조-및-특성"><span>구조 및 특성</span></a></h3><p>인덱스의 리프 노드는 항상 실제 데이터 레코드의 주소값을 가진다.</p><p><img src="'+p+'" alt="image"></p><p>데이터 파일의 레코드는 INSERT된 순서로 저장되어 있지 않다. 레코드가 삭제되어 빈 공간이 생기면 가능한 한 삭제된 공간을 재활용하도록 DBMS가 설계되기 때문에 항상 INSERT된 순서로 저장되지는 않는다.</p><p>인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. 이를 위해 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가진다.</p><h3 id="인덱스-키-추가-및-삭제" tabindex="-1"><a class="header-anchor" href="#인덱스-키-추가-및-삭제"><span>인덱스 키 추가 및 삭제</span></a></h3><p><strong>[인덱스 키 추가]</strong></p><p>새로운 키 값을 B-Tree에 저장할 적절한 위치를 검색해야 한다. 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다. 리프 노드가 꽉 차서 저장할 수 없을 때는 리프 노드가 Split(분리)되어야 하는데, 이는 상위 브랜치 노드까지 처리 범위가 넓어진다. 따라서 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 든다.</p><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p>대부분의 RDBMS의 데이터 파일에서 레코드는 특정 기준으로 정렬되지 않고 임의 순서로 저장된다. 하지만 InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 PK 순서로 정렬되어 저장된다. 이는 오라클의 IOT(Index Organized Table)나 MS-SQL의 클러스터 테이블과 같은 구조를 말한다. InnoDB에서는 사용자가 별도의 명령이나 옵션을 선택하지 않아도 디폴트로 클러스터링 테이블이 생성된다.</p></div><p><strong>[인덱스 키 삭제]</strong></p><p>해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다. 삭제 마킹된 공간은 재활용할 수 있다. 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 디스크 I/O가 필요한 작업이다. MySQL 5.5 이상 버전의 InnoDB 스토리지 엔진에서는 버퍼링되어 지연 처리될 수 있다. (서버가 내부적으로 처리하므로 특별히 걱정할 것은 없다.)</p><p><strong>[인덱스 키 변경]</strong></p><p>인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 단순히 인덱스 상의 키 값만 변경하는 것은 불가하다. 먼저 키 값을 삭제한 후 다시 새로운 키 값을 추가하는 방식으로 처리된다. InnoDB 스토리지 엔진을 사용하는 테이블에 대해서는 이 작업 모두 체인지 버퍼를 이용해 지연 처리될 수 있다.</p><p><strong>[인덱스 키 검색]</strong></p><p>인덱스를 검색하는 작업은 B-Tree 루트 노드부터 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행하는데 이 과정을 &#39;트리 탐색&#39;이라 한다. 이 작업은 SELECT 뿐만 아니라 UPDATE, DELETE를 처리하기 위해 항상 레코드를 먼저 검색해야 할 때도 수행된다.</p><p>B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다. 부등호 비교 조건에서도 인덱스를 활용할 수 있지만 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다. 또한 인덱스 키 값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 기능을 사용할 수 없다. 이미 변형된 값은 B-Tree 인덱스에 존재하는 값이 아니다. 따라서 함수나 연산을 수행한 결과로 정렬, 검색하는 작업은 B-Tree의 장점을 이용할 수 없으므로 주의해야 한다.</p><h3 id="인덱스-사용에-영향을-미치는-요소" tabindex="-1"><a class="header-anchor" href="#인덱스-사용에-영향을-미치는-요소"><span>인덱스 사용에 영향을 미치는 요소</span></a></h3><p><strong>[인덱스 키 값의 크기]</strong></p><p><strong>페이지(Page) 또는 블록(Block)</strong><br> InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지(Page) 또는 블록(Block)이라 하며, 디스크의 모든 읽기/쓰기 작업의 최소 단위가 된다. 또한 페이지는 InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이다.</p><p>DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조다. 자식 노드의 개수는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다. MySQL 5.7 버전부터 InnoDB 스토리지 엔진의 페이지 크기를 <code>innodb_page_size</code> 시스템 변수를 이용해 4KB ~ 64KB 사이 값을 선택할 수 있지만 기본값은 16KB다.</p><p><img src="'+l+`" alt="image"></p><p>그림 8.7의 경우 하나의 인덱스 페이지(16KB)에 저장할 수 있는 키의 개수는 16 * 1024 / (16 + 12) = 585개 저장할 수 있다. -&gt; 자식 노드를 585개 가질 수 있다.</p><p>인덱스 키 값이 커지면 (키 값의 크기가 두 배인 32Byte 로) 16 * 1024 / (32 + 12) = 372개 저장할 수 있다.</p><p>SELECT 쿼리가 레코드 500개를 읽어야 한다면 전자는 인덱스 페이지 한 번으로 해결될 수 있지만, 후자는 적어도 최소한 2번 이상 디스크로부터 읽어야 한다. 결국 <u>인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고 그만큼 느려짐</u>을 의미한다.</p><p>또한 인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스 크기가 커진다는 것을 의미한다. 하지만 인덱스를 캐시해 두는 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시 영역은 크기가 제한적이기 때문에 메모리에 캐시해둘 수 있는 레코드의 수는 줄어든다. 자연히 메모리 효율이 떨어지는 결과를 가져온다.</p><p><strong>[B-Tree 깊이]</strong></p><p>깊이는 상당히 중요하지만 직접 제어할 수 없다. 인덱스 키 값의 평균 크기가 늘어나면</p><p>인덱스 B-Tree 깊이가 3, 키 값이 16바이트인 경우에는 최대 2억 (585 * 585 * 585)개 정도 키 값을 담을 수 있지만, 키 값이 32바이트로 늘어나면 5천만(372 * 372 * 372) 개로 줄어든다.</p><p>B-Tree의 깊이는 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결된다. 결론적으로 인덱스 키 값의 크기가 커지면 커질수록 한 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 같은 레코드 건수라 하더라도 B-Tree 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 됨을 의미한다.</p><p>인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋다.</p><p><strong>[선택도]</strong></p><p>인덱스에서 선택도(Selectivity)와 기수성(Cardinality)는 거의 같은 의미로 사용되며, 모든 키 값 가운데 유니크한 값의 수를 의미한다. 전체 인덱스 키 값은 100개인데 그 중 유니크한 값의 수는 10개라면 기수성은 10이다. <u>인덱스 키 값 가운데 중복 값이 많아지면 많아질 수록 기수성은 낮아지고 선택도도 떨어진다. 인덱스는 선택도가 높을 수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.</u></p><p>country, city 칼럼이 포함된 tb_city 테이블을 예로 들자. tb_city 테이블의 전체 레코드 건수는 1만 건이며 country 칼럼으로만 인덱스가 생성되어 있다. tb_city 테이블에는 국가와 도시가 중복해서 저장되어 있지 않다.</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> tb_city<span class="token punctuation">(</span></span>
<span class="line">	country <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">	city <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">	<span class="token keyword">INDEX</span> ix_country<span class="token punctuation">(</span>country<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>다음 쿼리를 실행했을 때 내부적인 쿼리와 인덱스의 효율성을 살펴보자</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tb_test <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">&#39;KOREA&#39;</span> <span class="token operator">AND</span> city <span class="token operator">=</span> <span class="token string">&#39;SEOUL&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><p><strong>country 칼럼의 유니크한 값의 개수가 10개</strong><br> 유니크 값이 10개이므로 10개의 country의 city 정보가 저장되어 있다. 전체 레코드 건수를 유니크한 값의 개수로 나누면 하나의 키 값으로 검색했을 때 대략 몇 건의 레코드가 일치할 지 예측할 수 있다.<br> country = &#39;KOREA&#39; 조건으로 인덱스를 검색하면 1,000건 (10,000 / 10)이 일치한다 예상할 수 있다. 1,000건 가운데 city = &#39;SEOUL&#39;인 레코드는 1건이므로 999건은 불필요하게 읽은 것이다.</p></li><li><p><strong>country 칼럼의 유니크한 값의 개수가 1,000개</strong><br> 유니크 값이 1,000개이므로 1,000개 country의 city 정보가 저장되어 있다. 전체 레코드 건수를 유니크 값의 개수로 나누면 대략 한 국가당 10개의 도시 정보가 저장되어 있을 것이라 예측할 수 있다.<br> country = &#39;KOREA&#39; 조건으로 인덱스를 검색하면 10건 (10,000 / 1,000)이 일치할 것이며 그 10건 중에서 city = &#39;SEOUL&#39;인 레코드는 1건이므로 9건만 불필요하게 읽은 것이다.</p></li></ul><p>이처럼 인덱스에서 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미친다.</p><p><strong>[읽어야 하는 레코드 건수]</strong><br> 인덱스를 통해 테이블의 레코드를 읽는 것은 바로 테이블 레코드를 읽는 것보다 높은 비용이 드는 작업이다. 테이블에 레코드가 100만 건 있는데 그 중 50만 건을 읽어야 하는 쿼리가 있다고 하자. 전체 테이블을 모두 읽어서 필요 없는 50만 건을 버리는 것이 효율적일지, 인덱스를 통해 필요한 50만 건만 읽어 오는 것이 효율적일지 판단해야 한다.</p><p><u>인덱스를 통해 읽어야 할 레코드 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적</u>이다. (일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드를 1건 읽는 것이 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업으로 예측한다.)</p><p>전체 100만 건 레코드 가운데 50만 건을 읽어야 하는 작업은 인덱스 손익 분기점인 20~25%보다 훨씬 크기 때문에 MySQL 옵티마이저는 인덱스를 사용하지 않고 직접 테이블을 처음부터 끝까지 읽어서 처리할 것이다.</p><h3 id="데이터-읽기" tabindex="-1"><a class="header-anchor" href="#데이터-읽기"><span>데이터 읽기</span></a></h3><h4 id="인덱스-레인지-스캔" tabindex="-1"><a class="header-anchor" href="#인덱스-레인지-스캔"><span>인덱스 레인지 스캔</span></a></h4><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> EMPLOYEES <span class="token keyword">WHERE</span> first_name <span class="token operator">BETWEEN</span> <span class="token string">&#39;Ebbe&#39;</span> <span class="token operator">AND</span> <span class="token string">&#39;Gad&#39;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><img src="`+t+'" alt="image"></p><p>검색해야 할 인덱스 범위가 결정됬을 때 사용한다. 검색 값의 수나 검색 결과 레코드 건수와 상관없이 레인지 스캔이라고 표현한다. 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종 리프 노드까지 찾아들어가야 필요한 레코드의 시작 지점을 알 수 있다.</p><p>시작 위치를 찾으면 그 때부터 리프 노드의 레코드만 순서대로 읽으면 된다. 이처럼 차레대로 쭉 읽는 것을 &#39;스캔&#39;이라고 표현한다. 만약 스캔하다가 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔한다. 그리고 최종적으로 스캔을 멈춰야 할 위치에 도달하면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리를 끝낸다.</p><p>두꺼운 선은 스캔해야 할 위치 검색을 위한 비교 작업을 의미하며 두꺼운 화살표가 지나가는 리프 노드의 레코드 구간은 실제 스캔 범위를 표현한다.</p><p>그림 8.8은 실제 인덱스만을 읽는 경우를 보여준다. 하지만 B-Tree 인덱스의 리프 노드를 스캔하면서 실제 데이터 파일의 레코드를 읽어와야 하는 경우는 어떨까</p><p><img src="'+o+`" alt="image"></p><p>어떤 방식으로 스캔하든 상관없이, 해당 인덱스를 구성하는 칼럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다. 별도의 정렬 과정이 수반되지 않고 인덱스 자체의 정렬 특성 때문에 자동으로 그렇게 된다.</p><p>또 한 가지 중요한 것은 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다. 이 때 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, <u>레코드 한 건 한 건 단위로 랜덤 I/O가 한 번씩 일어난다</u>. 그래서 인덱스를 통해 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류된다. 그리고 <u>인덱스를 통해 읽어야 할 데이터 레코드가 20~25%를 넘으면 인덱스를 통한 읽기보다 테이블 데이터를 직접 읽는 것이 더 효율적인 처리 방식</u>이 된다.</p><p><strong>[인덱스 레인지 스캔의 3단계]</strong></p><ol><li>인덱스 탐색(Index Seek) : 인덱스에서 조건 만족하는 값이 저장된 위치를 찾는다.</li><li>인덱스 스캔(Index Scan) : 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 읽는다.</li><li>2번에서 읽어들인 인덱스 키와 레코드 주소를 통해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.</li></ol><p>쿼리가 필요로 하는 데이터에 따라 3번 과정은 필요 없을 수도 있다. 이를 &#39;커버링 인덱스&#39; 라고 한다. 커버링 인덱스로 처리되는 쿼리는 디스크 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 상당히 줄어들고 성능은 그만큼 빨라진다. MySQL 서버에는 1번과 2번 단계의 작업이 얼마나 수행됬는지 확인할 수 있게 다음과 같은 상태 값을 제공한다.</p><ul><li><code>Handler_read_key</code> : 1번 단계(Index Seek) 실행된 횟수</li><li><code>Handler_read_next</code>, <code>Handler_read_prev</code> : 2번 단계(Index Scan)로 읽은 레코드 건수 <ul><li><code>Handler_read_next</code>는 인덱스 정순으로 읽은 레코드 건수</li><li><code>Handler_read_prev</code>는 인덱스 역순으로 읽은 레코드 건수</li><li><code>Handler_read_first</code>, <code>Handler_read_last</code>는 인덱스의 첫 번째 레코드와 마지막 레코드를 읽은 횟수를 의미하는데, MIN(), MAX()와 같이 제일 큰/작은 값만 읽는 경우 증가하는 상태 값이다.</li></ul></li></ul><p>이 상태 값들은 읽은 레코드 건수를 의미하는데 실제 인덱스만 읽었는지 인덱스를 통해 데이터 레코드를 읽었는지(3번 단계)는 구분하지 않는다.</p><h4 id="인덱스-풀-스캔" tabindex="-1"><a class="header-anchor" href="#인덱스-풀-스캔"><span>인덱스 풀 스캔</span></a></h4><p>인덱스 레인지 스캔과는 달리 <u>인덱스의 처음부터 끝까지 모두 읽는 방식</u>이다. 대표적으로 <u>쿼리의 조건절이 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우</u> 인덱스 풀 스캔 방식이 사용된다. 예를 들어 인덱스는 (A, B, C) 순서로 만들어져 있지만 쿼리의 조건 절은 B 칼럼이나 C 칼럼으로 검색하는 경우다.</p><p>이 방식은 인덱스 레인지 스캔보다 빠르지 않지만 테이블 풀 스캔보다는 효율적이다. 인덱스에 포함된 칼럼만으로 쿼리를 처리할 수 있는 경우 테이블의 레코드를 읽을 필요가 없기 때문이다. 인덱스의 전체 크기는 테이블 자체 크기보다 훨씬 작으므로 인덱스 풀 스캔은 테이블 전체를 읽는 것보다 적은 디스크 I/O로 쿼리를 처리할 수 있다.</p><p>인덱스뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 이 방식으로 처리되지 않는다.</p><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p>인덱스 풀 스캔 방식 또한 인덱스를 사용하지만 효율적인 방식은 아니며, 일반적으로 인덱스를 생성하는 목적은 아니다. 역으로 테이블 전체를 읽거나 인덱스 풀 스캔 방식으로 인덱스를 사용하는 경우는 &quot;인덱스를 (효율적으로) 사용하지 못한다.&quot; 라는 표현을 사용한다.</p></div><h4 id="루즈-인덱스-스캔" tabindex="-1"><a class="header-anchor" href="#루즈-인덱스-스캔"><span>루즈 인덱스 스캔</span></a></h4><p>말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다. Oracle DBMS의 인덱스 스킵 스캔과 작동방식은 비슷하지만 MySQL에서는 이를 &#39;루즈 인덱스 스캔&#39;이라고 한다. 앞의 두 가지 접근 방법(인덱스 레인지 스캔 / 인덱스 풀 스캔)은 루즈 인덱스 스캔과 상반된 의미에서 타이트(Tight) 인덱스 스캔으로 분류한다.</p><p>루즈 인덱스 스캔은 <u>중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어간다</u>. 일반적으로 GROUP BY 또는 집합 함수 가운데 MAX() 또는 MIN() 함수에 대해 최적화하는 경우에 사용된다.</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> dept_no<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>emp_no<span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">FROM</span> DEPT_EMP</span>
<span class="line"><span class="token keyword">WHERE</span> dep_no <span class="token operator">BETWEEN</span> <span class="token string">&#39;d002&#39;</span> <span class="token operator">AND</span> <span class="token string">&#39;d004&#39;</span></span>
<span class="line"><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> dept_no</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+i+`" alt="image"></p><p>이 쿼리에서 사용된 dept_emp 테이블은 dept_no, emp_no 두 개의 칼럼으로 인덱스가 생성되어 있다. 또한 이 인덱스는 (dept_no, emp_no) 조합으로 정렬까지 되어 있어서 그림 8.11과 같이 dept_no별로 첫 번째 레코드의 emp_no 값만 읽으면 된다. 즉 인덱스에서 WHERE 조건을 만족하는 범위 전체를 스캔할 필요가 없다는 것을 알고 있기 때문에 조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 이동한다.</p><h4 id="인덱스-스킵-스캔" tabindex="-1"><a class="header-anchor" href="#인덱스-스킵-스캔"><span>인덱스 스킵 스캔</span></a></h4><p>DB 서버에서 인덱스의 핵심은 값이 정렬돼 있다는 것이며, 이로 인해 인덱스를 구성하는 칼럼 순서가 매우 중요하다.</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> employees <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> ix_gender_birthdate<span class="token punctuation">(</span>gender<span class="token punctuation">,</span> birth_date<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>이 인덱스를 사용하려면 WHERE 조건에 gender 칼럼에 대한 비교가 필수다.</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token comment">-- 인덱스 사용 불가</span></span>
<span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> birth_date <span class="token operator">&gt;=</span> <span class="token string">&#39;1965-12-01&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">-- 인덱스 사용 가능</span></span>
<span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> gender <span class="token operator">=</span> <span class="token string">&#39;M&#39;</span> <span class="token operator">AND</span> birth_date <span class="token operator">&gt;=</span> <span class="token string">&#39;1965-12-01&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>MySQL 8.0 버전부터 옵티마이저가 gender 칼럼을 건너뛰어 birth_date 칼럼만으로 인덱스 검색이 가능하게 해 주는 인덱스 스킵 스캔 최적화 기능이 도입되었다. 물론 8.0 이전 버전에서도 비슷하게 최적화를 수행하는 루즈 인덱스 스캔 기능이 있었지만 이 기능은 GROUP BY 작업을 처리하기 위해 인덱스를 사용하는 경우에만 적용할 수 있었다. 8.0 버전에 도입된 인덱스 스킵 스캔은 WHERE 조건절의 검색을 위해 사용 가능하도록 용도가 훨씬 넓어졌다.</p><p>인덱스 스킵 스캔을 비활성화하고 8.0 이전 버전에서 어떤 실행 계획으로 처리됐는지 살펴보면</p><p><img src="`+c+'" alt="image"></p><p>WHERE 절에 gender 조건 없이 birth_date 비교 조건만 가지기 때문에 인덱스를 효율적으로 이용할 수 없다. (꼭 필요한 부분만 접근하는 것을 의미)</p><ul><li>type 칼럼이 index라고 표시 → 인덱스를 처음부터 끝까지 읽었다. (풀 인덱스 스캔)</li><li>employees 테이블의 모든 칼럼을 조회했다면 → 테이블 풀 스캔</li></ul><p>인덱스 스킵을 활성화하면</p><p><img src="'+r+'" alt="image"></p><ul><li>type 칼럼이 range으로 표시 → 인덱스에서 꼭 필요한 부분만 읽었다.</li><li>Extra 칼럼에 &#39;Using index for scan&#39; 표시 → 인덱스 스킵 스캔을 활용해 데이터 조회했다.</li></ul><p><img src="'+d+`" alt="image"></p><p>옵티마이저는 우선 gender 칼럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 gender 칼럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리한다. 내부적으로 아래 2개 쿼리를 실행하는 것과 비슷한 형태의 최적화를 실행한다.</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> gender <span class="token operator">=</span> <span class="token string">&#39;M&#39;</span> <span class="token operator">AND</span> birth_date <span class="token operator">&gt;=</span> <span class="token string">&#39;1965-12-01&#39;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> gender <span class="token operator">=</span> <span class="token string">&#39;F&#39;</span> <span class="token operator">AND</span> birth_date <span class="token operator">&gt;=</span> <span class="token string">&#39;1965-12-01&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>[단점]</strong></p><ul><li>WHERE 절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 한다. <ul><li>만약 유니크한 값의 개수가 많다면 옵티마이저는 인덱스에서 스캔해야 할 시작점을 검색하는 작업이 많아져 쿼리의 처리 성능이 오히려 느려질 수 있다. 예를 들어 (emp_no, dept_no) 조합으로 만들어진 인덱스에서 스킵 스캔을 실행한다 가정하면 사원의 수만큼 레인지 스캔 시작점을 검색하는 작업이 필요해져 쿼리의 성능이 매우 떨어진다.</li></ul></li><li>쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스) <ul><li>모든 칼럼을 조회하면 인덱스 칼럼 이외 나머지 칼럼도 필요하기 때문에 풀 테이블 스캔으로 실행 계획을 수립한다.</li></ul></li></ul><h3 id="다중-칼럼-인덱스" tabindex="-1"><a class="header-anchor" href="#다중-칼럼-인덱스"><span>다중 칼럼 인덱스</span></a></h3><p>실제 서비스용 데이터베이스에서는 2개 이상의 칼럼을 포함한 인덱스가 더 많이 사용된다. 두 개 이상의 칼럼으로 구성된 인덱스를 다중 칼럼 인덱스라고 하며 2개 이상의 칼럼이 연결됬다고 해서 <code>Concatenated Index</code>라고도 한다.</p><p>인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬돼 있다. 즉 두 번째 칼럼의 정렬은 첫 번째 칼럼이 똑같은 레코드에서만 의미가 있다. 그림 8.13에서는 칼럼이 2개 뿐이지만, 만약 칼럼이 4개인 인덱스를 생성한다면 세 번째 칼럼은 두 번째 칼럼에 의존해서 정렬되고, 네 번째 칼럼은 다시 세 번째 칼럼에 의존해서 정렬된다.</p><h3 id="인덱스의-정렬-및-스캔-방향" tabindex="-1"><a class="header-anchor" href="#인덱스의-정렬-및-스캔-방향"><span>인덱스의 정렬 및 스캔 방향</span></a></h3><p>인덱스의 키 값은 항상 오름차순 또는 내림차순으로 정렬되어 저장된다. 하지만 인덱스가 오름차순으로 생성됐다 해서 그 인덱스를 오름차수로만 읽을 수 있다는 뜻은 아니다. 그 인덱스를 거꾸로 끝에서부터 읽으면 내림차순으로 정렬된 인덱스로도 사용될 수 있다. 옵티마이저가 쿼리에 따라 인덱스를 어느 방향으로 읽을지 실행 계획을 만들어 낸다.</p><p><strong>[인덱스의 정렬]</strong></p><p>DBMS는 인덱스를 생성하는 지점에 인덱스를 구성하는 각 칼럼의 정렬을 오름차순 또는 내림차순으로 정렬할 수 있다. MySQL 5.7 버전까지는 칼럼 단위로 정렬 순서를 혼합(ASC or DESC)해서 인덱스를 생성할 수 없었다. 이런 문제점을 해결하기 위해 숫자 칼럼의 경우 -1을 곱한 값을 저장하는 우회 방법을 사용했다. 하지만 MySQL 8.0 버전부터는 다음과 같은 형태의 정렬 순서를 혼합한 인덱스도 생성할 수 있게 되었다.</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> ix_teamname_userscore <span class="token keyword">ON</span> employee <span class="token punctuation">(</span>team_name <span class="token keyword">ASC</span><span class="token punctuation">,</span> user_score <span class="token keyword">DESC</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>[스캔 방향]</strong></p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees</span>
<span class="line"><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> first_name <span class="token keyword">DESC</span></span>
<span class="line"><span class="token keyword">LIMIT</span> <span class="token number">1</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>인덱스는 항상 오름차순으로 정렬돼 있지만 인덱스를 최대값부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다는 것을 MySQL 옵티마이저는 이미 알고 있다. 그래서 위의 쿼리는 <u>인덱스를 역순으로 접근해 첫 번째 레코드만 읽으면 된다</u>. 그림 8.14는 인덱스를 정순으로 읽는 경우와 역순으로 읽는 경우를 보여준다.</p><p><img src="`+u+'" alt="image"></p><p>인덱스 생성 시점에 오름차순/내림차순으로 정렬되지만 쿼리가 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순/내림차순 정렬 효과를 얻을 수 있다.</p><p>오름차순으로 생성된 인덱스를 정순으로 읽으면 출력되는 결과 레코드는 자동으로 오름차순으로 정렬된 결과가 되고, 역순으로 읽으면 그 결과는 내림차순으로 정렬된다.</p><p><strong>[내림차순 인덱스]</strong><img src="'+m+'" alt="image"></p><ul><li>오름차순 인덱스(Ascending Index) : 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스</li><li>내림차순 인덱스(Descending Index) : 큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스</li><li>인덱스 정순 스캔(Forward Index Scan) : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔</li><li>인덱스 역순 스캔(Backward Index Scan) : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔</li></ul><p><img src="'+k+`" alt="image"></p><ul><li>인덱스 역순 스캔이 정순 스캔에 비해 느릴 수 밖에 없는 이유 <ul><li>페이지 잠금이 인덱스 정순 스캔에 적합한 구조</li><li>페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조</li></ul></li></ul><p>일반적으로 <code>ORDER BY ... DESC</code> 쿼리가 소량의 레코드에 드물게 실행된다면 내림차순 인덱스를 고려할 필요는 없다. 하지만 쿼리가 많은 레코드를 조회하면서 빈번하게 실행된다면 내림차순 인덱스가 더 효율적이라고 볼 수 있다.</p><p>또한 많은 쿼리가 인덱스의 앞쪽만 또는 뒤쪽만 집중적으로 읽어서 인덱스의 특정 페이지 잠금이 병목이 될 것으로 예상된다면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는 데 도움이 된다.</p><h3 id="가용성과-효율성" tabindex="-1"><a class="header-anchor" href="#가용성과-효율성"><span>가용성과 효율성</span></a></h3><h4 id="비교-조건의-종류와-효율성" tabindex="-1"><a class="header-anchor" href="#비교-조건의-종류와-효율성"><span>비교 조건의 종류와 효율성</span></a></h4><p>다중 칼럼 인덱스에서 각 칼럼의 순서와 조건이 동등 비교 <code>=</code>인지 아니면 크다 <code>&gt;</code> 또는 작다 <code>&lt;</code> 같은 범위 조건인지에 따라 각 인덱스 칼럼의 활용 형태가 달라지며, 그 효율 또한 달라진다.</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> dept_emp</span>
<span class="line"><span class="token keyword">WHERE</span> dept_no<span class="token operator">=</span><span class="token string">&#39;d002&#39;</span> <span class="token operator">AND</span> emp_no <span class="token operator">&gt;=</span> <span class="token number">10114</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>이 쿼리를 위해 dept_emp 테이블에 각 칼럼의 순서만 다른 두 가지 케이스로 인덱스를 생성했다고 가정하자. 위의 쿼리가 처리되는 동안 각 인덱스에 어떤 차이가 있을까?</p><p><img src="`+g+'" alt="image"></p><ul><li><p>케이스 A: INDEX (dept_no, emp_no)<br><code>dept_no=&#39;d002&#39; AND emp_no &gt;= 10114</code> 인 레코드를 찾고 그 이후에는 dept_no가 &#39;d002&#39; 아닐 때까지 인덱스를 쭉 읽기만 하면 된다. 조건을 만족하는 레코드가 5개라고 할 때 5건의 레코드를 찾는데 꼭 필요한 5번의 비교 작업만 수행한 것이므로 상당히 효율적으로 인덱스를 이용했다.</p></li><li><p>케이스 B: INDEX (emp_no, dept_no)<br><code>emp_no &gt;= 10114 AND dept_no=&#39;d002&#39;</code>인 레코드를 찾고 그 이후에는 dept_no가 &#39;d002&#39;인지 비교하는 과정을 거쳐야 한다.</p><p>최종적으로 <code>dept_no=&#39;d002&#39;</code> 조건을 만족하는 레코드 5건을 찾기 위해 7번의 비교 과정을 거쳤다. 그 이유는 다중 칼럼 인덱스의 정렬 방식 때문이다. (인덱스의 N번째 키 값은 N-1 번째 키 값에 대해서 다시 정렬됨) 케이스 A 인덱스에서 2번째 칼럼인 emp_no는 비교 작업의 범위를 좁히는 데 도움을 준다. 하지만 케이스 B 인덱스에서 2번째 칼럼인 dept_no는 비교 작업의 범위를 좁히는 데 도움을 주지 못하고 단지 쿼리 조건이 맞는지 검사하는 용도로만 사용했다.</p></li></ul><p>공식적인 명칭은 아니지만 케이스 A 인덱스에서 두 조건(<code>dept_no=&#39;d002&#39; AND emp_no &gt;= 10114</code>)과 같이 작업의 범위를 결정하는 조건을 &#39;작업 범위 결정 조건&#39; 이라 하고, 케이스 B 인덱스의 (<code>dept_no=&#39;d002&#39;</code> ) 조건과 같이 비교 작업의 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건을 &#39;필터링 조건&#39; 또는 &#39;체크 조건&#39; 이라 표현한다. 결국, <u>케이스 A 인덱스에서 dept_no 칼럼과 emp_no 칼럼은 모두 &#39;작업 범위 결정 조건&#39; 에 해당하지만, 케이스 B 인덱스에서는 emp_no 칼럼만 &#39;작업 범위 결정 조건&#39; 이고 dept_no 칼럼은 &#39;필터링 조건&#39;으로 사용된 것</u>이다.</p><p>작업 범위 결정 조건은 많을수록 쿼리의 처리 성능을 높이지만 <u>체크 조건은 많다 해서 쿼리의 처리 성능을 높이지는 못한다. 오히려 쿼리 실행을 느리게 만들 때가 많다.</u></p><h4 id="가용성" tabindex="-1"><a class="header-anchor" href="#가용성"><span>가용성</span></a></h4><p>B-Tree 인덱스는 왼쪽 값에 기준해서(Left-most) 오늘쪽 값이 정렬되어 있다. 여기서 왼쪽이란 하나의 칼럼 내에서 뿐만 아니라 다중 칼럼 인덱스의 칼럼에 대해서도 함께 적용된다.</p><ul><li>케이스 A: INDEX (first_name)</li><li>케이스 B: INDEX (dept_no, emp_no)</li></ul><p>하나의 칼럼으로 검색해도 왼쪽 부분이 없으면 인덱스 레인지 스캔 방식의 검색이 불가하다. 또한 다중 칼럼 인덱스에서도 왼쪽 칼럼의 값을 모르면 인덱스 레인지 스캔을 사용할 수 없다.</p><p><img src="'+b+`" alt="image"></p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> fist_name <span class="token operator">LIKE</span> <span class="token string">&#39;%mer&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>이 쿼리는 인덱스 레인지 스캔 방식으로 인덱스를 이용할 수 없다. first_name 칼럼에 저장된 왼쪽부터 한 글자씩 비교해 가면서 레코드를 찾아야 하는데 <u>왼쪽 부분이 고정되지 않았기 떄문</u>이다. 따라서 정렬 우선 순위가 낮은 뒷부분의 값만으로 왼쪽 기준(Left-most) 정렬 기반의 인덱스인 B-Tree 에서는 인덱스의 효과를 얻을 수 없다.</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> emp_no <span class="token operator">&gt;=</span> <span class="token number">10144</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>인덱스가 (dept_no, emp_no) 순서대로 생성돼 있다면 선행 칼럼인 dept_no 조건 없이 emp_no 값으로만 검색하면 인덱스를 효율적으로 사용할 수 없다. 케이스 B의 인덱스는 다중 칼럼 인덱스로 <u>dept_no 칼럼에 대해 먼저 정렬한 후, 다시 emp_no 칼럼 값으로 정렬돼 있기 떄문</u>이다. 이러한 왼쪽 값 기준 규칙은 GROUP BY, ORDER BY 절에도 똑같이 적용된다.</p><h4 id="가용성과-효율성-판단" tabindex="-1"><a class="header-anchor" href="#가용성과-효율성-판단"><span>가용성과 효율성 판단</span></a></h4><p>기본적으로 B-Tree 인덱스의 특성상 다음 조건에서는 사용할 수 없다. 즉 작업 범위 결정 조건으로 사용할 수 없음을 의미하며, 경우에 따라서 체크 조건으로 인덱스를 사용할 수 있다.</p><ul><li>NOT-EQUAL로 비교된 경우(&quot;&lt;&gt;&quot;, &quot;NOT IN&quot;, &quot;NOT BETWEEN&quot;, &quot;IS NOT NULL&quot;)</li><li>LIKE &#39;%??&#39; (앞부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우 <ul><li>\`.. WHERE column LIKE &#39;%ABC&#39;</li><li>\`.. WHERE column LIKE &#39;_ABC&#39;</li><li>\`.. WHERE column LIKE &#39;%A%&#39;</li></ul></li><li>스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교된 경우 <ul><li>\`.. WHERE SUBSTRING(column,1,1) = &#39;X&#39;</li><li><code>.. WHERE DAYOFMONTH(column) = 1</code></li></ul></li><li>NON-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우 <ul><li><code>.. WHERE column = deterministic_function()</code></li></ul></li><li>데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교 가능한 경우) <ul><li><code>.. WHERE char_column = 10</code></li></ul></li><li>문자열 데이터 타입의 콜레이션이 다른 경우 <ul><li><code>.. WHERE utf8_bin_char_column = euckr_bin_char_column</code></li></ul></li></ul><p>다중 칼럼으로 만들어진 인덱스는 어떤 조건에서 사용될 수 있고 어떤 경우에 절대 사용할 수 없는지 살펴보자.</p><p><code>INDEX ix_test(column_1, column_2, column_3, ..., column_n)</code></p><ul><li>작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우 <ul><li><code>column_1</code> 칼럼에 대한 조건이 없는 경우</li><li><code>column_1</code> 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우</li></ul></li><li>작업 범위 결정 조건으로 인덱스를 사용하는 경우(i는 2보다 크고 n보다 작은 임의 값) <ul><li><code>column_1</code> ~ <code>column_(i - 1)</code> 칼럼까지 동등 비교 형태(&quot;=&quot; 또는 &quot;IN&quot;)로 비교</li><li><code>column_i</code> 칼럼에 대해 다음 연산자 중 하나로 비교 <ul><li>동등 비교(&quot;=&quot; 또는 &quot;IN&quot;)</li><li>크다 작다 형태(&quot;&gt;&quot; 또는 &quot;&lt;&quot;)</li><li>LIKE로 좌측 일치 패턴(<code>LIKE &#39;ABC%&#39;</code>)</li></ul></li></ul></li></ul><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token comment">-- 다음 쿼리는 인덱스 사용 불가</span></span>
<span class="line"><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">WHERE</span> column1 <span class="token operator">&lt;&gt;</span> <span class="token number">2</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">-- 다음 쿼리는 column_1, column_2까지 범위 결정 조건으로 사용됨</span></span>
<span class="line"><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">WHERE</span> column_1 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">AND</span> column_2 <span class="token operator">&gt;</span> <span class="token number">10</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">-- 다음 쿼리는 column_1, column_2, column_3까지 범위 결정 조건으로 사용됨</span></span>
<span class="line"><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">WHERE</span> column_1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">AND</span> column_2 <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">AND</span> column_3 <span class="token operator">&lt;=</span> <span class="token number">10</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">-- 다음 쿼리는 column_1, column_2, column_3까지 범위 결정 조건으로,</span></span>
<span class="line"><span class="token comment">-- column_4는 체크 조건으로 사용됨</span></span>
<span class="line"><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">WHERE</span> column_1 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">AND</span> column_2 <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">AND</span> column_3 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token operator">AND</span> column_4 <span class="token operator">&lt;&gt;</span> <span class="token number">100</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">-- 다음 쿼리는 column_1, column_2, column_3, column_4까지 범위 결정 조건</span></span>
<span class="line"><span class="token comment">-- 좌측 패턴 일치 LIKE 비교는 크다 또는 작다 비교와 동급으로 생각하면 됨</span></span>
<span class="line"><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">WHERE</span> column_1 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">AND</span> column_2 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">AND</span> column_3 <span class="token operator">=</span> <span class="token number">30</span> <span class="token operator">AND</span> column_4 <span class="token operator">LIKE</span> <span class="token string">&#39;김승%&#39;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">-- 다음 쿼리는 column_1, column_2, column_3, column_4, column_5 칼럼까지 모두 범위 결정 조건</span></span>
<span class="line"><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">WHERE</span> column_1 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">AND</span> column_2 <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">AND</span> column_3 <span class="token operator">=</span> <span class="token number">30</span> <span class="token operator">AND</span> column_4 <span class="token operator">=</span> <span class="token string">&#39;김승환&#39;</span> <span class="token operator">AND</span> column_5 <span class="token operator">=</span> <span class="token string">&#39;서울&#39;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="references" tabindex="-1"><a class="header-anchor" href="#references"><span>References</span></a></h2><ul><li>Real MySQL 8.0.1 / 백은빈.이성욱 저</li></ul>`,139),v=[h];function E(y,I){return a(),s("div",null,v)}const B=n(_,[["render",E],["__file","index.html.vue"]]),T=JSON.parse('{"path":"/database/","title":"Index","lang":"en-US","frontmatter":{},"headers":[{"level":3,"title":"분류","slug":"분류","link":"#분류","children":[]},{"level":2,"title":"B-Tree 인덱스","slug":"b-tree-인덱스","link":"#b-tree-인덱스","children":[{"level":3,"title":"구조 및 특성","slug":"구조-및-특성","link":"#구조-및-특성","children":[]},{"level":3,"title":"인덱스 키 추가 및 삭제","slug":"인덱스-키-추가-및-삭제","link":"#인덱스-키-추가-및-삭제","children":[]},{"level":3,"title":"인덱스 사용에 영향을 미치는 요소","slug":"인덱스-사용에-영향을-미치는-요소","link":"#인덱스-사용에-영향을-미치는-요소","children":[]},{"level":3,"title":"데이터 읽기","slug":"데이터-읽기","link":"#데이터-읽기","children":[]},{"level":3,"title":"다중 칼럼 인덱스","slug":"다중-칼럼-인덱스","link":"#다중-칼럼-인덱스","children":[]},{"level":3,"title":"인덱스의 정렬 및 스캔 방향","slug":"인덱스의-정렬-및-스캔-방향","link":"#인덱스의-정렬-및-스캔-방향","children":[]},{"level":3,"title":"가용성과 효율성","slug":"가용성과-효율성","link":"#가용성과-효율성","children":[]}]},{"level":2,"title":"References","slug":"references","link":"#references","children":[]}],"git":{"updatedTime":1731928726000,"contributors":[{"name":"depark","email":"mem29238@gmail.com","commits":1}]},"filePathRelative":"database/index.md"}');export{B as comp,T as data};
